Title:  Writeup for Project 3, Fall 2015
Date:  11/10/2015
Group 8
James Lynch	jamestly@usc.edu
Austin Spiegel	aspiegel@usc.edu
Haley Lenner	lenner@usc.edu
 
I. Requirements:

The requirements for this Project are to implement the software-managed TLB, virtual memory, and RPC calls for creating Locks, Condition Variables, and Monitor Variables.  The TLB acts as a cache and gives the illusion of fast access to virtual address translation over a large address space.  Virtual memory is implemented to use main memory as a cache for the disk.  This allows us to concurrently run programs that are larger than main memory, reading 'pages' of code or data from either the executable or a swap file.  RPCs allow machines to run procedures on another machine via message passing.  For Project 3, this is done using a single Server with up to five clients.

II. Assumptions:



III. Design:
/*** OVERALL ***/
Exec, Fork, and Exit stay the same.  There are a handful of new functions to deal with a PageFault exception.  These new functions are described in depth below.  A PageFault exception can 'trickle up' and cause a handful of other behaviors.  The general flow of a PageFault exception is as follows:

PageFault_Handler (if page is not in TLB) -> IPTMissHandler (if page is not in memory) -> MemoryFull_Handler (if memory is full)

To model memory, we use an inverted page table (IPT).  The inverted page table stores the same data as the TLB, with the addition of the pages address space.  This allows us to modify the physical page's corresponding virtual page (load into/remove from memory).  We use memBitMap to allocate free space within main memory.  Additionally, we acquire/release memLock when searching or changing the IPT/main memory.  

AddrSpace saw some changes as well.  The PageTable now also stores whether the page is 'swapped' (saved to the SwapFile) and the pages offset in either the executable or swapFile.  We no longer preload the executable, because there is not enough space in main memory to do so.  We've added two new functions, SavetoMemory and RemoveFromMemory which allows us to load/save virtual page data.  These are explained in greater detail below.

/*** PageFault_Handler ***/
This is the function called when a PageFault exception occurs.  A PageFault exception occurs when a virtual address is not in the TLB.

We calculate the VPN, so that we know which virtual page to put in the TLB.  We then acquire the memLock because we will be looping through the IPT.  

As we loop through the IPT, we search for a physical page with the same VPN as the VPN we calculated earlier.  If we find such a page, we check to see that it is valid and that it exists in the same address space as our currentThread.  A page cannot be trusted if it is not valid.  Additionally, multiple physical pages can have the same VPN because they can be from different address spaces.

If we find the physical page we are looking for, we break out of the loop.  Now, we turn off interrupts as we are about to update the TLB.  We check if the PPN we found is not equal to -1.  int PPN is initialized to -1; if the VPN we were looking for is not in the IPT, PPN stays equal to -1.  If PPN is equal to -1, we call IPTMiss_Handler (explained below).

If the PPN is not equal to -1, we know that the correct page is in main memory.  We update the tlbCounter, which is an index to the TLB entry we will be evicting.  Before evicting from the TLB, we check if the page we are about to evict is valid. If the page is valid, we want to propagate the dirty bit to the IPT.

We then update the TLB, copying over the corresponding data from the IPT and setting the valid bit to true.  We release memLock and turn off interrupts.

/*** IPTMiss_Handler ***/
This function is only called from PageFault_Handler.  It is called if the desired VPN was not found in the IPT.  Thus, the IPT needs to read the corresponding page in from disk or swap file.

First, we find a spot in main memory to load the missing page into.  If there is no space available, we call MemoryFull_Handler... explained below.

If we are using FIFO memory replacement scheme, we push the new physical page number on to the back of the memory queue.  We then load the page into memory via the currentThread's address space... explained below.  Finally we return the new physical page number so that the PageFault_Handler knows what information to load into the TLB.

/*** MemoryFull_Handler ***/
This function is called when we are looking for a spot in main memory to place a page from disk/swap file, but main memory is full.  We need to find a page to evict, by calling GetPageToEvict()... explained below.

We then loop through the TLB, checking if the physical page we are about to evict exists in the TLB.  If it does, and it is valid, we propagate the dirty information to the IPT.  We use the address space of the page we are about to evict to save remove the page from main memory... explained below.

/*** GetPageToEvict ***/
This function decides which page to evict depending on what eviction scheme is being used.  If the FIFO memory eviction scheme is being used, we pop a physical page number from the front of the queue.  If the random memory eviction scheme is being used, we randomly choose a physical page to evict.  In either case we return the physical page number to be evicted.

/*** ADDRSPACE ***/
AddrSpace(OpenFile* executable): This function has been changed greatly since Project 2.  We create the pageTableLock, which protects the address space's page table while it is being edited.  We then save the executable to a pointer within the address space (as opposed to deleting it, as was done previously).  We acquire the pageTableLock and create a new pageTable.  The pageTable has enough pages for the code, init data, and uninit data from the executable, as well as one userStack for the first thread in the process.  We loop through the pageTable, initializing any pages that came from the executable with their offset (virtual page's address within the executable) and VPN.  We then loop through the pages in the userStack, setting their VPN but purposely not setting their offset as they do not exist in the executable (they're blank pages).  Finally, we release the pageTableLock.

LoadIntoMemory(int vpn, int ppn): This function is new for Project 3.  In this function, we load a virtual page from disk or swap file into main memory.  This function is only ever called upon a PageFaultException.  Therefore, we do not worry about acquiring the memLock because it has been acquired by the calling function.

First, we acquire the pageTableLock as we will be modifying information in the pageTable.  There are 3 possibilities for loading:

	Swapped: If the virtual page has been swapped, we read pageSize bytes in from the swapFile where the virtual page's offset is.  We then clear the swapBitMap of that page, so that the space in the swapFile can be used by other data.  We set the swapped flag to false, the offset to -1, and the physical page's dirty bit to true (because this page is modified data).

	Executable: If the virtual page is in the executable, we read pageSize bytes in from the executable where the virtual page's offset is.  We then set the physical page's dirty bit to false because we are loading unmodified code or data.

	Neither: The page can exist in neither the swap file nor the executable if the page is a blank userStack page.  In this case, we just set the physical page's dirty bit to false because the page has yet to be modified.

Following all cases, we copy the virtual page's information into the corresponding index in the IPT.  We also set the virtual page's physical page number to its new PPN and set its valid bit to true (because it is in main memory).

RemoveFromMemory(int vpn, int ppn): This function is new for Project 3.  In this function, we update the address space's pageTable to reflect that the virtual page has been removed from memory.  If the physical page is dirty, we save it to a swap file.

First, we acquire the pageTableLock.  If the physical page is dirty, we find a location in the swapFile to save it to (using the swapBitMap).  We then write pageSize bytes from the physical page's location in main memory to the allocated location in the swapFile.  We save the virtual page's offset as the 'swapPage' * PageSize and set the swapped flag to true.  Regardless of whether or not the physical page is dirty, we reset the virtual page's physical page number and set its valid bit to false (because it is no longer in main memory).  Finally, we release the pageTableLock.

InitRegisters(): This function has barely changed.  We acquire the pageTableLock at the beginning of this function because we will be using the numPages to calculate the StackReg address and do not want it to be modified by a new thread if a context switch occurs.

SaveState(): This function has been modified.  On a context switch, we want to invalidate the TLB.  Whenever dealing with the TLB, we turn off interrupts.  We loop through the TLB, and if a TLB entry is valid, we propogate it's dirty bit.  We set all TLB enetries to invalid.

NewUserStack(): This function has a new name (used to be NewPageTable) and also initializes the new fields in pageTableEntry (offset & swapped).

ReclaimStack(int stackPage):  We disable interrupts for this function because it will modify the TLB.  We loop through a thread's userStack (stackPage + (UserStackSize / PageSize)) checking if any of its virtual page's are in main memory.

If they are, we invalidate the entry in the IPT and check the TLB.  If the physical page is also in the TLB (and it is valid), we invalidate it.  Finally, we clear the memBitMap of the physical page so it can be used by other processes.  If using the FIFO memory management scheme, we remove the physical page number from the queue.

We also check if the page has been swapped, if so we clear the swapBitMap of the virtual page so that it can be used by other processess.

Finally, we reset all of the virtual page's information and disable interrupts.

ReclaimPageTable():  ReclaimPageTable is identical to ReclaimStack except we loop through the entire pageTable instead of a single userStack.

/*** RPCs ***/
We gave user programs the ability to call Remote Procedures by editing our Syscalls from Project 2 (CreateLock_Syscall, AcquireLock_Syscall, ReleaseLock_Syscall, DestroyLock_Syscall, CreateCV_Syscall, Wait_Syscall, Signal_Syscall, Broadcast_Syscall, and DestroyCV_Syscall) and implementing four new Syscalls for Monitor Variables (CreateMV_Syscall, SetMV_Syscall, GetMV_Syscall, DestroyMV_Syscall).  We changed these Syscalls to do the following if Networking was enabled: (1) Validate inputs as only the Client machine can validate that the user program is passing valid virtual addresses that it owns, (2) Constructing a message, (3) Sending the Request, (4) Waiting on a Response, (5) Parsing the Response, and finally (6) Returning the pertinent value to the user program so it may resume execution. 

On the Server side, we implemented a method, Server( ), inside of nettest.cc.  The Server is an infinite loop that has the following responsibilities: (1) Wait for Requests, (2) Parse the Request to get the RequestType and its inputs, (3) Calling the requested Remote Procedure Call, (4) Constructing a Response, and depending on whether the Client Machine needs to wait on a Server resource either (5A) Add the Response to a Queue or (5B) Send the Response Immediately.  If a Response is added to a Queue (as is the case in AcquireLock and Wait), the Response is sent when either another Machine calls ReleasesLock (for AcquireLock) or another Machine calls Signal or Broadcast (for Wait). 

The implementation for our Server Locks and Conditions differ slightly from our original implementation in Project 1.  Because the Server has no notion of a Clientâ€™s Thread, a Wait Queue of Threads and a Lock Owner Thread no longer make sense.  Instead we store the Machine ID and Mailbox IDs of the owning Thread and construct a Response Message and store that in a Wait Queue.  This is equivalent to putting a Thread to sleep as the calling Machine will pause execution at postOffice->Receive.  Otherwise the logic is pretty much the same.

Since Machines will eventually be running the same user program and will need a new way to communicate and share data (as they no longer share a common Address Space), we also added Monitor Variables to Project 3.  This allows user programs to define arrays of integers that are shared.  They can be retrieved with GetMV, created with CreateMV, destroyed with DestroyMV, and updated with SetMV.  The logic for these methods is pretty intuitive.  All Monitor Variables are implemented as arrays as this gives us the most flexibility without needing to implement differently typed Monitor Variable implementations.



IV. Implementation:
+ Files Modified: 
	System.h
	System.cc
	Syscall.h
	exception.cc
	addrspace.h
	addrspace.cc
	progtest.cc
	start.s
	nettest.cc

+ Files added:
	execTest.c
	forkTest.c
	clientTest1.c
	clientTest2.c
	clientTest3.c

+ Data Structures added/modified

	/*** SYSTEM ***/
    class IPTEntry : public TranslationEntry
    {
        public:
            AddrSpace * space; // Process memory belongs to
    };

    IPTEntry *ipt;
    OpenFile *swapFile;
    BitMap *swapBitMap;
    bool isFIFO;
    list<int> memFIFO;
    int tlbCounter;

    /*** ADDRSPACE ***/
    class PageTableEntry : public TranslationEntry
	{
	    public:
	        PageTableEntry(); // Initialize a Page Table Entry
	        ~PageTableEntry(); // De-allocate Page Table Entry
	        bool swapped; // In swap file? If !swapped && !valid, then load from executable
	        int offset; // The last bits of virtual address for access within Page
	};

	Lock *pageTableLock;
	OpenFile *executable;

	/*** NETTEST ***/
	struct ServerLock {
   		char *serverlockName;
        std::queue<Mail*> waitqueue;
        bool toDelete;
        bool state;
        int machineID;
        int mailbox;
   	}

   	struct ServerCV {
   		string name;
    	bool toDelete;
    	int conditionlock;
    	std::queue<Mail*> waitqueue;
   	}

   	struct MonitorVariable {
   		string name;
    	int *values;
    	unsigned int size;
   	}

+ Functions added and in which file.

addrspace.cc
	PageTableEntry::PageTableEntry()
	void AddrSpace::LoadIntoMemory(int vpn, int ppn)
	void AddrSpace::RemoveFromMemory(int vpn, int ppn)
	int AddrSpace::NewUserStack()

exception.cc
	unsigned int GetPageToEvict()
	int MemoryFull_Handler()
	int IPTMiss_Handler(int vpn)
	void PageFault_Handler(unsigned int vaddr)
	

	void SendRequest(string request)
	int ReceiveResponse()
	int CreateMV_Syscall(unsigned int vaddr, int idlength, int mvsize)
	void SetMV_Syscall(int indexmv, int indexvar, int value)
	int GetMV_Syscall(int indexmv, int indexvar)
	void DestroyMV_Syscall(int indexmv)

nettest.cc
	void Server()
	void SendResponse(string response, int machineID, int mailboxID)
	int dovalidatelockindex(int index, PacketHeader inPktHdr, MailHeader inMailHdr)
	void doCreateLock(char *name, PacketHeader inPktHdr, MailHeader inMailHdr)
	void doAcquireLock(int indexlock, PacketHeader inPktHdr, MailHeader inMailHdr)
	void doReleaseLock(int indexlock, PacketHeader inPktHdr, MailHeader inMailHdr)
	void doDestroyLock(int indexlock, PacketHeader inPktHdr, MailHeader inMailHdr)
	int validatecvindeces(unsigned int indexcv, unsigned int indexlock, int machineID, int mailboxID)
	void CreateCV(string cvname, int machineID, int mailboxID)
	void WaitCV(unsigned int indexcv, unsigned int indexlock, int machineID, int mailboxID)
	void DeleteCondition(unsigned int indexcv)
	void SignalCV(unsigned int indexcv, unsigned int indexlock, int machineID, int mailboxID)
	void BroadcastCV(unsigned int indexcv, unsigned int indexlock, int machineID, int mailboxID)
	void DestroyCV(unsigned int indexcv, int machineID, int mailboxID)
	void CreateMV(string mvname, int mvsize, int machineID, int mailboxID)
	void SetMV(unsigned int indexmv, unsigned int indexvar, int value, int machineID, int mailboxID)
	void GetMV(unsigned int indexmv, unsigned int indexvar, int machineID, int mailboxID)
	void DestroyMV(unsigned int indexmv, int machineID, int mailboxID)

+ Functions modified and in which file.
progtest
	void StartProcess(char *filename)

syscall.h
	int CreateMV(char *id, int idlength, int arraysize)
	void SetMV(int indexmv, int indexvar, int value)
	int GetMV(int indexmv, int indexvar)
	void DestroyMV(int indexmv)

addrspace.cc/addrspace.h
	Addrspace()
	int InitRegisters()
	void SaveState()
	int NewUserStack()
	void ReclaimStack(int stackPage)
	void ReclaimPageTable()

exception.cc
	int CreateLock_Syscall(unsigned int vaddr, int len)
	int AcquireLock_Syscall(int indexlock)
	int ReleaseLock_Syscall(int indexlock)
	int DestroyLock_Syscall(int indexlock)
	int CreateCV_Syscall(unsigned int vaddr, int len)
	int Wait_Syscall(int indexcv, int indexlock)
	int Signal_Syscall(int indexcv, int indexlock)
	int Broadcast_Syscall(int indexcv, int indexlock)
	int DestroyCV_Syscall(int indexcv)
	void ExceptionHandler(ExceptionType which)

V. Testing:  (For each test case, you must show)
+ How to test

/*** PARTS 1 & 2 ***/
nachos -x ../test/matmult
	// This runs matmult once and finishes correctly
nachos -x ../test/sort
	// This runs sort once and finishes correctly
nachos -x ../test/execTest
	// This execs 2 matmults, the main thread and 2 process threads finish correctly
nachos -x ../test/forkTest
	// This forks matmult once and finishes correctly

+ Test Output
matmult: Exit: 7220
sort: Exit: 1023
execTest: Exit: 0 \n Exit: 7220 \n Exit: 7220
forkTest: Exit: 0 \n Exit: 7220

/*** LOCK & CV RPCS ***/
Go to network directory and type the following:
	
	For each of following, open a Server by doing:
	'nachos -server -m 0'
	'nachos -x ../test/mvtest -m 1'

	Open 3 Clients and Run:
	'nachos -x ../test/clientTest1 -m 1'
	'nachos -x ../test/clientTest2 -m 2'
	'nachos -x ../test/clientTest3 -m 3'

+ Test Output
Our output will say pass/fail for validation tests. 

VI. Discussion:

All of the RPCs work 100% properly. We did not design our tests to run with -rs values. Our tests display proper functionality for the RPCs. 